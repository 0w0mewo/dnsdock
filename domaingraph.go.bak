/*
package servers

import (
	"github.com/gyuho/goraph"
	"strings"
	"fmt"
)


type DomainGraph struct {
  graph goraph.Graph
  roots []goraph.Node
}


func NewDomainGraph() *DomainGraph {
  res := &DomainGraph {}
  res.graph = goraph.NewGraph()
  return res
}


//
//type DomainGraphNode {
//   name String
//   children []*DomainGraphNode
//} 
//
//
func (g *DomainGraph) AddDomain(domain string)  {
  splitted := strings.Split(domain,".")
  var parent goraph.Node = nil
  for i := len(splitted)-1; i >= 0; i-- {
    var curComp = splitted[i]
    node, err := g.graph.GetNode(goraph.StringID(curComp))
    if err != nil {
      fmt.Printf("Node %s does not exist, add it\n", curComp)
      node = goraph.NewNode(curComp)
      g.graph.AddNode(node)
    }
    if parent == nil {
      parent = node
      g.roots = append(g.roots,node)
    } else {
      g.graph.AddEdge(parent.ID(),node.ID(),1)
      fmt.Printf("Add edge from %s to %s \n", parent, node)
    }
  }
}

func (g *DomainGraph) Display()  {
  for _, c := range g.roots {
    g.displayNode(c)
  }
}

func (g *DomainGraph) displayNode(curNode goraph.Node)  {
  fmt.Println("Node: %s visited", curNode.ID())
  children, err := g.graph.GetTargets(curNode.ID())
  fmt.Printf("Number of children: %i\n", len(children))
  if err == nil {
    for _,c := range children {
      
      g.displayNode(c)
    }
  }
}
//
//
//func (g DomainGraph) RemoveDomain(domain String)  {
//
//}
//
//func (g DomainGraph) getNodes(query String) []*DomainGraphNode {
//  splittedQuery = strings.Split(strings.ToLower(query), ".")
//}
//
//func resolveDomain(query  []String, n *DomainGraphNode)
//{
//}
//
//func (n DomainGraphNode) Name() String {
//  return n.name
//}
//
//func (n DomainGraphNode) Children() []*DomainGraphNode {
//  return n.children
//}*/
